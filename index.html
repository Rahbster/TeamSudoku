<!DOCTYPE html>
<html>
<head>
    <title>Sudoku P2P Proof-of-Concept (Pure HTML/JS)</title>
    <style>
        body { font-family: sans-serif;
    background-image: url('http://googleusercontent.com/image_generation_content/51');
    background-repeat: no-repeat;
    background-position: center center;
    background-size: cover;
    background-attachment: fixed;}
        .container { display: flex; gap: 20px; }
        .column { flex: 1; padding: 10px; border: 1px solid #ccc; }
        textarea { width: 100%; height: 100px; }
        /*This is a comment that follows my preferred C# style*/
        #sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 36px);
            width: 324px;
            border: 3px solid black;
            margin: 0 auto;
        }
        .grid-cell {
            width: 36px;
            height: 36px;
            border: 1px solid black;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            cursor: pointer;
            box-sizing: border-box;
            transition: background-color 0.3s;
        }
        .subgrid-border-right {
            border-right: 3px solid black;
        }
        .subgrid-border-bottom {
            border-bottom: 3px solid black;
        }
        /* New CSS for collapsible section */
        #sudoku-grid-area.hidden {
            display: none;
        }
        /* New CSS for collapsible section */
        #signaling-area.hidden {
            display: none;
        }
        /* New CSS for cell coloring */
        .invalid-cell {
            background-color: lightcoral;
        }
        .solved-puzzle {
            background-color: lightgreen !important;
        }
        /* New CSS for highlighting */
        .highlight-cell {
            background-color: lightgray !important;
        }
        /* New CSS to prevent altering initial cells */
        .preloaded-cell {
            background-color: #f0f0f0;
            cursor: default;
        }
        .active-cell {
            background-color: gold;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center; /* This centers the items vertically */
        }
        /*This is a comment*/
        button {
            background-color: #007bff; /* A vibrant blue, common in Halo UI */
            color: #fff;
            border: 2px solid #0056b3;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: #0056b3;
            border-color: #004494;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 2px 4px rgba(0, 0, 0, 0.1);
        }
        /* New CSS for QR code section */
        #qr-signaling-area {
            text-align: center;
        }
        #qr-code-display {
            padding: 10px;
            border: 1px solid #ccc;
            display: inline-block;
            margin-top: 10px;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>

    <div id="sudoku-grid-area">
        <div class="header-container">
            <h2>The Game</h2>
            <button onclick="loadPuzzle()">Load New Puzzle</button>
        </div>
        <p>Once connected, click on a grid cell to change its value. The change will appear on the other player's screen.</p>
        
        <div id="sudoku-grid"></div>
        <hr>
    </div>
    
    <button onclick="toggleSignalingArea()">Toggle P2P Configuration</button>
    <div id="signaling-area" class="hidden">
        <h1>P2P Sudoku PoC</h1>
        <p>Open this file in two separate browser tabs to simulate two players. Follow the steps below to connect them.</p>

        <label for="signaling-method">Choose Connection Method:</label>
        <select id="signaling-method" onchange="toggleSignalingMethod()">
            <option value="none">-- Select a method --</option>
            <option value="manual">Manual Copy/Paste</option>
            <option value="qr">QR Code Scan</option>
        </select>
        <br><br>
        <label for="player-role">Choose Player Role:</label>
        <select id="player-role" onchange="togglePlayerRole()">
            <option value="none">-- Select a role --</option>
            <option value="host">Player 1 (Host)</option>
            <option value="joiner">Player 2 (Joiner)</option>
        </select>
        <hr>

        <div id="manual-signaling-area" class="hidden">
            <div id="p1-manual-area" class="hidden">
                <div class="container">
                    <div class="column">
                        <h2>Player 1 (Host)</h2>
                        <button onclick="createOfferManual()">1. Create Offer</button>
                        <p>Copy the text below and paste it into the "Received Offer" box for Player 2.</p>
                        <textarea id="offer-text" readonly></textarea>
                        <button onclick="copyToClipboard('offer-text')">Copy Offer</button>
                    </div>
                </div>
                <hr>
                <div class="container">
                    <div class="column">
                        <h2>Player 1 (Final Step)</h2>
                        <p>Paste Answer from Player 2 into the box below:</p>
                        <textarea id="received-answer-text"></textarea>
                        <button onclick="addAnswerManual()">Add Answer & Connect</button>
                        <p id="p1-status">Status: Disconnected</p>
                    </div>
                </div>
            </div>
            <div id="p2-manual-area" class="hidden">
                <div class="container">
                    <div class="column">
                        <h2>Player 2 (Joiner)</h2>
                        <p>1. Paste Offer from Player 1 into the box below:</p>
                        <textarea id="received-offer-text"></textarea>
                        <button onclick="createAnswerManual()">2. Create Answer</button>
                        <p>Copy the text below and paste it into the "Received Answer" box for Player 1.</p>
                        <textarea id="answer-text" readonly></textarea>
                        <button onclick="copyToClipboard('answer-text')">Copy Answer</button>
                    </div>
                </div>
                <hr>
                <div class="container">
                    <div class="column">
                        <h2>Player 2 (Final Step)</h2>
                        <p id="p2-status">Status: Disconnected</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="qr-signaling-area" class="hidden">
            <div id="p1-qr-area" class="hidden">
                <div class="container">
                    <div class="column">
                        <h2>Player 1 (Host)</h2>
                        <p>1. Create Offer and show the QR code to Player 2.</p>
                        <button onclick="createOfferQr()">Create QR Code Offer</button>
                        <p>Scan this QR code on the other device:</p>
                        <div id="qr-code-display"></div>
                    </div>
                </div>
                <hr>
                <div class="container">
                    <div class="column">
                        <p id="p1-qr-status">Status: Disconnected</p>
                    </div>
                </div>
            </div>
            <div id="p2-qr-area" class="hidden">
                <div class="container">
                    <div class="column">
                        <h2>Player 2 (Joiner)</h2>
                        <p>1. Scan the QR code from Player 1.</p>
                        <button onclick="startQrScanner()">Start QR Scanner</button>
                        <p>Point your camera at the other device's QR code.</p>
                        <div id="qr-reader" style="width: 300px;"></div>
                        <p>Or, if Player 1 has scanned your answer, show this code:</p>
                        <div id="qr-code-display-answer"></div>
                    </div>
                </div>
                <hr>
                <div class="container">
                    <div class="column">
                        <p id="p2-qr-status">Status: Disconnected</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <script>
        //This is a comment that follows my preferred C# style
        
        let peerConnection;
        let dataChannel;
        let isInitiator = false;
        let initialSudokuState = [];
        let activeCell = null;
        let qrScanner = null;

        const offerTextarea = document.getElementById('offer-text');
        const receivedOfferTextarea = document.getElementById('received-offer-text');
        const answerTextarea = document.getElementById('answer-text');
        const receivedAnswerTextarea = document.getElementById('received-answer-text');
        const p1Status = document.getElementById('p1-status');
        const p2Status = document.getElementById('p2-status');
        const p1QrStatus = document.getElementById('p1-qr-status');
        const p2QrStatus = document.getElementById('p2-qr-status');
        const sudokuGrid = document.getElementById('sudoku-grid');
        const sudokuGridArea = document.getElementById('sudoku-grid-area');
        const signalingArea = document.getElementById('signaling-area');
        const manualSignalingArea = document.getElementById('manual-signaling-area');
        const qrSignalingArea = document.getElementById('qr-signaling-area');
        const p1ManualArea = document.getElementById('p1-manual-area');
        const p2ManualArea = document.getElementById('p2-manual-area');
        const p1QrArea = document.getElementById('p1-qr-area');
        const p2QrArea = document.getElementById('p2-qr-area');

        let pressTimer;
        let isLongPressActive = false; // New global flag
        let lastEventTimestamp = 0;

        //Initializes the WebRTC PeerConnection
        function initializeWebRTC() {
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    console.log('New ICE candidate:', event.candidate);
                }
            };
            
            peerConnection.ondatachannel = event => {
                dataChannel = event.channel;
                setupDataChannel(dataChannel);
            };
        }

        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('Data Channel is open!');
                p1Status.textContent = 'Status: Connected!';
                p2Status.textContent = 'Status: Connected!';
                p1QrStatus.textContent = 'Status: Connected!';
                p2QrStatus.textContent = 'Status: Connected!';
                toggleSignalingArea();
            };

            channel.onmessage = event => {
                const data = JSON.parse(event.data);
                if (data.type === 'move') {
                    const cell = document.getElementById(`cell-${data.row}-${data.col}`);
                    if (cell) {
                        cell.textContent = data.value;
                    }
                    checkGridState();
                } else if (data.type === 'initial-state') {
                    loadPuzzle(data.state);
                }
            };
        }

        // --- Signaling Functions (Manual Copy/Paste) ---
        async function createOfferManual() {
            isInitiator = true;
            initializeWebRTC();
            
            dataChannel = peerConnection.createDataChannel('sudoku-game');
            setupDataChannel(dataChannel);

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            peerConnection.onicegatheringstatechange = () => {
                if (peerConnection.iceGatheringState === 'complete') {
                    offerTextarea.value = JSON.stringify(peerConnection.localDescription);
                }
            };
        }

        async function createAnswerManual() {
            initializeWebRTC();
            const offer = JSON.parse(receivedOfferTextarea.value);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            peerConnection.onicegatheringstatechange = () => {
                if (peerConnection.iceGatheringState === 'complete') {
                    answerTextarea.value = JSON.stringify(peerConnection.localDescription);
                }
            };
        }

        async function addAnswerManual() {
            const answer = JSON.parse(receivedAnswerTextarea.value);
            if (peerConnection.signalingState !== 'stable') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            }
        }

        // --- Signaling Functions (QR Code) ---
        async function createOfferQr() {
            isInitiator = true;
            initializeWebRTC();
            
            dataChannel = peerConnection.createDataChannel('sudoku-game');
            setupDataChannel(dataChannel);

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            peerConnection.onicegatheringstatechange = () => {
                if (peerConnection.iceGatheringState === 'complete') {
                    const sdp = JSON.stringify(peerConnection.localDescription);
                    //Clear old QR code if it exists
                    document.getElementById('qr-code-display').innerHTML = '';
                    new QRCode(document.getElementById('qr-code-display'), {
                        text: sdp,
                        width: 256,
                        height: 256,
                    });
                    p1QrStatus.textContent = 'Status: Offer created. Waiting for other player to scan.';
                }
            };
        }

        function startQrScanner() {
            //Destroy any previous scanner to prevent multiple camera feeds
            if (qrScanner) {
                qrScanner.stop();
                qrScanner = null;
            }

            qrScanner = new Html5QrcodeScanner("qr-reader", { fps: 10, qrbox: {width: 250, height: 250} });
            qrScanner.render(onScanSuccess, onScanFailure);
            p2QrStatus.textContent = 'Status: Scanner started. Point camera at QR code.';
        }

        async function onScanSuccess(decodedText) {
            console.log(`QR code detected: ${decodedText}`);
            try {
                const sdp = JSON.parse(decodedText);
                if (sdp.type === 'offer') {
                    //Player 2 receives the offer and creates an answer
                    initializeWebRTC();
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    peerConnection.onicegatheringstatechange = () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            const answerSdp = JSON.stringify(peerConnection.localDescription);
                            //Stop the scanner and show the answer QR code
                            if (qrScanner) {
                                qrScanner.stop().then(() => {
                                    document.getElementById('qr-reader').innerHTML = '';
                                    document.getElementById('qr-reader').style.display = 'none';
                                    p2QrStatus.textContent = 'Status: Answer created. Show this QR code to Player 1.';
                                    //Remove this line
                                    document.getElementById('qr-code-display-answer').innerHTML = '';
                                    new QRCode(document.getElementById('qr-code-display-answer'), {
                                        text: answerSdp,
                                        width: 256,
                                        height: 256,
                                    });
                                }).catch(err => console.error(err));
                            }
                        }
                    };
                } else if (sdp.type === 'answer' && isInitiator) {
                    //Player 1 receives the answer and connects
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
                    if (qrScanner) {
                        qrScanner.stop().then(() => {
                            document.getElementById('qr-reader').innerHTML = '';
                            document.getElementById('qr-reader').style.display = 'none';
                        }).catch(err => console.error(err));
                    }
                    p1QrStatus.textContent = 'Status: Answer received. Connecting...';
                }
            } catch (e) {
                console.error('Invalid QR code content:', e);
            }
        }
        
        function onScanFailure(error) {
            console.warn(`QR code scan error: ${error}`);
        }

        // --- Clipboard Functions ---
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            document.execCommand('copy');
            alert('Copied to clipboard!');
        }
        
        // --- Game Logic (Sudoku Grid) ---
        function createGrid() {
            if (sudokuGrid.firstChild) {
                while (sudokuGrid.firstChild) {
                    sudokuGrid.removeChild(sudokuGrid.firstChild);
                }
            }
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.id = `cell-${row}-${col}`;
                    cell.textContent = ''; 
                    if ((col + 1) % 3 === 0 && col < 8) {
                        cell.classList.add('subgrid-border-right');
                    }
                    if ((row + 1) % 3 === 0 && row < 8) {
                        cell.classList.add('subgrid-border-bottom');
                    }
                    
                    // --- New Long-Press and Click Logic ---
                    cell.addEventListener('mousedown', startPressTimer);
                    cell.addEventListener('touchstart', startPressTimer);
                    cell.addEventListener('mouseup', handleCellClick);
                    cell.addEventListener('touchend', handleCellClick);
                    cell.addEventListener('mouseleave', () => clearTimeout(pressTimer));

                    sudokuGrid.appendChild(cell);
                }
            }
        }
        
        function startPressTimer(event) {
            clearTimeout(pressTimer); // Clear any existing timer
            isLongPressActive = false; // Reset the flag
            
            const cell = event.currentTarget;
            pressTimer = setTimeout(() => {
                handleLongPress(cell);
            }, 500); // 500ms for a long press
        }
        
        function handleCellClick(event) {
            clearTimeout(pressTimer);
            const currentTime = new Date().getTime();
            if (currentTime - lastEventTimestamp < 100) {
                lastEventTimestamp = 0;
                return;
            }
            lastEventTimestamp = currentTime;

            if (isLongPressActive) {
                isLongPressActive = false;
                return;
            }
            const cell = event.currentTarget;
            // Handle clicks on a preloaded cell.
            if (cell.classList.contains('preloaded-cell')) {
                const value = cell.textContent.trim();
                if (value !== '') {
                    clearAllHighlights();
                    highlightMatchingCells(value);
                }
                return;
            }
            // NEW LOGIC: Check if the clicked cell is already active
            if (activeCell === cell) {
                // If the cell is already active, toggle its value
                const currentValue = cell.textContent.trim();
                let newValue;
                
                if (currentValue === '9') {
                    newValue = '';
                } else if (currentValue === '') {
                    newValue = 1;
                } else {
                    newValue = parseInt(currentValue, 10) + 1;
                }
                
                cell.textContent = newValue;
                const move = {
                    type: 'move',
                    row: cell.id.split('-')[1],
                    col: cell.id.split('-')[2],
                    value: newValue
                };
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify(move));
                    console.log(`Sent move: Row ${move.row}, Col ${move.col}, Value ${move.value}`);
                }
                
                // After changing the value, update highlights and state
                clearAllHighlights();
                highlightMatchingCells(newValue.toString());
                checkGridState();
                
            } else {
                // If a different cell is clicked, make it the active one
                if (activeCell) {
                    activeCell.classList.remove('active-cell');
                }
                activeCell = cell;
                cell.classList.add('active-cell');
                // Clear all previous highlights and apply new ones
                clearAllHighlights();
                const value = cell.textContent.trim();
                if (value !== '') {
                    highlightMatchingCells(value);
                }
            }
        }
        
        function handleLongPress(cell) {
            isLongPressActive = true; // Set the flag
            const value = cell.textContent.trim();
            if (value !== '') {
                clearAllHighlights();
                highlightMatchingCells(value);
            }
        }
        
        function highlightMatchingCells(value) {
            const allCells = document.querySelectorAll('.grid-cell');
            allCells.forEach(cell => {
                if (cell.textContent.trim() === value && !cell.classList.contains('invalid-cell') && !cell.classList.contains('solved-puzzle')) {
                    cell.classList.add('highlight-cell');
                }
            });
        }
        
        function clearAllHighlights() {
            const allCells = document.querySelectorAll('.grid-cell');
            allCells.forEach(cell => {
                cell.classList.remove('highlight-cell');
            });
        }

        async function loadPuzzle(puzzleData) {
            createGrid();

            let puzzle = puzzleData;
            let isRemoteLoad = false;
            
            if (puzzleData) {
                isRemoteLoad = true;
            } else {
                try {
                    const response = await fetch('https://sugoku.onrender.com/board?difficulty=easy');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    puzzle = data.board;
                    initialSudokuState = puzzle;
                } catch (error) {
                    console.error('Failed to load puzzle:', error);
                    alert('Failed to load puzzle. Please ensure you are running a local web server to avoid CORS issues.');
                    return;
                }
            }
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    const value = puzzle[row][col];
                    cell.textContent = value === 0 ? '' : value;
                    // NEW LOGIC: Add the preloaded-cell class to non-empty cells
                    if (value !== 0) {
                        cell.classList.add('preloaded-cell');
                    }
                }
            }
            
            checkGridState();
            if (!isRemoteLoad && dataChannel && dataChannel.readyState === 'open') {
                const puzzleMessage = { type: 'initial-state', state: puzzle };
                dataChannel.send(JSON.stringify(puzzleMessage));
                console.log('Sent new puzzle to connected peer.');
            }
        }
        
        // New function to show/hide the signaling area
        function toggleSignalingArea() {
            signalingArea.classList.toggle('hidden');
            sudokuGridArea.classList.toggle('hidden');

            if (signalingArea.classList.contains('hidden')) {
                sudokuGridArea.scrollIntoView({ behavior: 'smooth' });
            }
            else {
                signalingArea.scrollIntoView({ behavior: 'smooth' });
            }
        }

        //New function to toggle signaling method UI
        function toggleSignalingMethod() {
            const method = document.getElementById('signaling-method').value;
            manualSignalingArea.classList.add('hidden');
            qrSignalingArea.classList.add('hidden');
            
            if (method === 'manual') {
                manualSignalingArea.classList.remove('hidden');
            } else if (method === 'qr') {
                qrSignalingArea.classList.remove('hidden');
            }
            
            // Re-run role toggle to ensure correct sub-area is displayed
            togglePlayerRole();
        }

        // New function to toggle player role UI
        function togglePlayerRole() {
            const role = document.getElementById('player-role').value;
            
            // Hide all role-specific sections first
            p1ManualArea.classList.add('hidden');
            p2ManualArea.classList.add('hidden');
            p1QrArea.classList.add('hidden');
            p2QrArea.classList.add('hidden');

            // Then show the relevant one
            if (role === 'host') {
                p1ManualArea.classList.remove('hidden');
                p1QrArea.classList.remove('hidden');
            } else if (role === 'joiner') {
                p2ManualArea.classList.remove('hidden');
                p2QrArea.classList.remove('hidden');
            }
        }

        // New validation functions
        function checkForConflicts(arr) {
            const seen = new Set();
            for (const num of arr) {
                if (num !== '' && seen.has(num)) {
                    return true;
                }
                if (num !== '') {
                    seen.add(num);
                }
            }
            return false;
        }

        function validatePuzzle() {
            const invalidCells = new Set();
            let isComplete = true;
            const gridValues = [];

            // Get current grid state and check for completeness
            for (let row = 0; row < 9; row++) {
                const rowValues = [];
                for (let col = 0; col < 9; col++) {
                    const cellValue = document.getElementById(`cell-${row}-${col}`).textContent.trim();
                    rowValues.push(cellValue);
                    if (cellValue === '') {
                        isComplete = false;
                    }
                }
                gridValues.push(rowValues);
            }

            // Check rows
            for (let row = 0; row < 9; row++) {
                if (checkForConflicts(gridValues[row])) {
                    for (let col = 0; col < 9; col++) {
                        if (gridValues[row][col] !== '') {
                            invalidCells.add(`cell-${row}-${col}`);
                        }
                    }
                }
            }

            // Check columns
            for (let col = 0; col < 9; col++) {
                const colValues = [];
                for (let row = 0; row < 9; row++) {
                    colValues.push(gridValues[row][col]);
                }
                if (checkForConflicts(colValues)) {
                    for (let row = 0; row < 9; row++) {
                        if (gridValues[row][col] !== '') {
                            invalidCells.add(`cell-${row}-${col}`);
                        }
                    }
                }
            }

            // Check 3x3 subgrids
            for (let blockRow = 0; blockRow < 3; blockRow++) {
                for (let blockCol = 0; blockCol < 3; blockCol++) {
                    const subgridValues = [];
                    for (let row = 0; row < 3; row++) {
                        for (let col = 0; col < 3; col++) {
                            subgridValues.push(gridValues[blockRow * 3 + row][blockCol * 3 + col]);
                        }
                    }
                    if (checkForConflicts(subgridValues)) {
                        for (let row = 0; row < 3; row++) {
                            for (let col = 0; col < 3; col++) {
                                if (gridValues[blockRow * 3 + row][blockCol * 3 + col] !== '') {
                                    invalidCells.add(`cell-${blockRow * 3 + row}-${blockCol * 3 + col}`);
                                }
                            }
                        }
                    }
                }
            }

            return { invalidCells: Array.from(invalidCells), isComplete: isComplete };
        }

        // Apply colors based on validation results
        function checkGridState() {
            const allCells = document.querySelectorAll('.grid-cell');
            allCells.forEach(cell => {
                cell.classList.remove('invalid-cell');
                cell.classList.remove('solved-puzzle');
                cell.classList.remove('highlight-cell');
            });
            const { invalidCells, isComplete } = validatePuzzle();
            if (invalidCells.length > 0) {
                invalidCells.forEach(id => {
                    document.getElementById(id).classList.add('invalid-cell');
                });
            } else if (isComplete) {
                allCells.forEach(cell => {
                    cell.classList.add('solved-puzzle');
                });
            }
        }
        
        window.onload = function() {
            createGrid();
            toggleSignalingMethod();
            togglePlayerRole();
        };
    </script>
</body>
</html>
